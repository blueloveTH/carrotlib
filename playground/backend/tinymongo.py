import openpyxl
import re
import os
import traceback

TYPES = {
    'int': int,
    'float': float,
    'str': str,
    'bool': bool,
    'ref': str,
}

REF_PATTERN = re.compile(r'=(\w+)!\$([A-Z])\$([0-9]+)')

def _row_name(sheet_name: str):
    return sheet_name + 'Row'

def get_sheet_headers(sheet):
    headers = []
    type_names = tuple(TYPES.keys())
    for row in sheet.iter_rows(min_row=1, max_row=1):
        for cell in row:
            assert cell.value is not None, "Header cell is empty"
            if ':' in cell.value:
                cell_name, cell_type = cell.value.split(':')
                cell_type = cell_type.strip()
                assert cell_type in type_names, f"Unknown type: {cell_type}"
            else:
                cell_name, cell_type = cell.value, 'str'
            headers.append((cell_name, cell_type))
    return headers

COMMON_HEADER = """# This file was auto-generated by playground/backend/tinymongo.py

from typing import Generic, TypeVar    
T = TypeVar('T', bound='Table')

class Table(Generic[T]):
    data: list[T]
    indexed_data: dict[str, T]

    def __init__(self, T: type, data: list[T]):
        self.data = [T(i) for i in data]
        self.indexed_data = {row.id: row for row in self.data}
        
    def __len__(self):
        return len(self.data)

    def __iter__(self):
        return iter(self.data)

    def __getitem__(self, i: int):
        return self.data[i]

    def with_id(self, id: str):
        assert type(id) is str
        return self.indexed_data.get(id)

    def objects(self, **queries) -> list[T]:
        results = []
        for row in self.data:
            for k, v in queries.items():
                if getattr(row, k) != v:
                    break
            else:
                results.append(row)
        return results


class _Row:
    def __init__(self, _data):
        self._data = _data

    def __repr__(self):
        cls_name = type(self).__name__
        values = []
        for i, name in enumerate(type(self).__fields__):
            values.append(f'{name}=' + repr(self._data[i]))
        return f'{cls_name}(' + ', '.join(values) + ')'

"""

def export_xlsl_to_db(input: str, output: str):
    wb = openpyxl.load_workbook(input, data_only=False, read_only=True)

    lines = []

    for sheet_name in wb.sheetnames:
        sheet = wb[sheet_name]
        headers = get_sheet_headers(sheet)
        print(sheet_name, headers)

        lines.append('class ' + _row_name(sheet_name) + '(_Row):')

        col_names = tuple(col_name for col_name, _ in headers)
        lines.append(f'    __fields__ = {col_names!r}')

        for i in range(len(headers)):
            col_name, col_type = headers[i]
            if col_type == 'ref':
                lines.extend([
                    '    @property',
                    '    def ' + f'{col_name}(self): return ' + f'ref(self._data[{i}])',
                ])
            else:
                lines.extend([
                    '    @property',
                    '    def ' + f'{col_name}(self) -> {col_type}: return ' + f'self._data[{i}]',
                ])
        lines.append('')

    lines.append('\nclass db:')

    for sheet_name in wb.sheetnames:
        sheet = wb[sheet_name]
        row_name = _row_name(sheet_name)
        headers = get_sheet_headers(sheet)
        lines.append(f"    {sheet_name}: Table[{row_name}] = Table({row_name}, [")
        for row in sheet.iter_rows(min_row=2):
            values = [cell.value for cell in row]
            if sum([1 for i in values if i is not None]) == 0:
                continue
            values[0] = row[0].coordinate
            assert len(values) == len(headers)
            for i, (col_name, col_type) in enumerate(headers):
                try:
                    values[i] = TYPES[col_type](values[i])
                except:
                    raise ValueError(f'{col_name}={values[i]!r} is not compatible with {col_type}')
            
                if col_type == 'ref':
                    if not REF_PATTERN.fullmatch(values[i]):
                        raise ValueError(f'{col_name}={values[i]!r} is not a valid ref')

            values = tuple(values)
            lines.append('        ' + repr(values) + ',')
        lines.append('    ])\n')


    with open(output, 'wt', encoding='utf-8') as f:
        f.write(COMMON_HEADER)

        AllTypes = ' | '.join([_row_name(name) for name in wb.sheetnames])
        f.write(f"""
def ref(formula: str) -> '{AllTypes}':
    # =Spell!$A$2
    assert formula[0] == '='
    sheet_name, coord = formula[1:].split('!')
    coord = coord.replace('$', '')
    return getattr(db, sheet_name)[coord]
""")

        f.write('\n\n')
        f.write('\n'.join(lines))



def build_excel(project: str):
    # walk through all .xlsx files
    for root, dirs, files in os.walk(project):
        for file in files:
            if file.endswith('.xlsx') and not file.startswith('~'):
                input = os.path.join(root, file)
                output = os.path.join(root, file.replace('.xlsx', '.py'))
                try:
                    print(f'Input: {input}')
                    export_xlsl_to_db(input, output)
                    print(f'Output: {output}')
                except Exception:
                    traceback.print_exc()


if __name__ == '__main__':
    export_xlsl_to_db('db.xlsx', 'db.py')
